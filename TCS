Linux Admin
1.LvM
*** How to Copy and how to take backups ***

3.ping server is not reachable(what is the next step)
4.How to search using port number
nc
traceroute
*** schedule job at 5 am and it has to delete the log files that are 10 days old ***
0 5 * * * find /var/log -type f -mtime +10 -name "*.log" -exec rm -f {} \;
ğŸ“˜ Explanation:
0 5 * * * â†’ Run daily at 05:00 AM
find â†’ searches in /var/log
-mtime +10 â†’ files older than 10 days
-exec rm -f {} â†’ delete each found file

Kuberenetes
*** Kubectl commmands ***
*** Image pull back off error ***
1ï¸âƒ£ ImagePullBackOff Error
Meaning:
It means Kubernetes tried to pull (download) the container image from the image registry (like Docker Hub, Quay, or a private repo) but failed repeatedly.
Common Causes:
*Incorrect image name or tag
Example: nginx:alpinee (wrong spelling)
*Private image repository (authentication needed)
Missing imagePullSecret
*Network issue
Cluster node cannot connect to Docker registry.
*DNS issue
Node cannot resolve the registry hostname.

How to check:
kubectl describe pod <pod-name>

Look at the Events section; youâ€™ll see messages like:
Failed to pull image "nginx:latest": rpc error: code = Unknown desc = Error response from daemon


Fix:
âœ… Check the image name and tag
âœ… If private registry â†’ create secret:
kubectl create secret docker-registry myregistrykey \
  --docker-server=<registry-url> \
  --docker-username=<username> \
  --docker-password=<password> \
  --docker-email=<email>
Then in Pod YAML:
imagePullSecrets:
  - name: myregistrykey
âœ… Check node network/DNS using:
kubectl get nodes -o wide
kubectl exec -it <pod> -- nslookup <registry-url>

****Pod pending state****
A Pod in Pending state means Kubernetes accepted the request but hasnâ€™t been able to schedule the Pod onto any node.
It is basically stuck before running.
âœ… Why a Pod goes into Pending State?
Here are the most common reasons with simple explanation:
| Reason                                                             | Meaning                                          | Example                                                          |
| ------------------------------------------------------------------ | ------------------------------------------------ | ---------------------------------------------------------------- |
| **Not enough CPU/Memory resources**                                | No node has free capacity to run the pod         | You requested `2 CPU and 4Gi memory`, but all nodes are full     |
| **No node matches nodeSelector/taints/tolerations/affinity rules** | Scheduling rules block the pod from being placed | Pod demands a node with label `env=prod` but no such node exists |
| **PVC (Persistent Volume Claim) not bound**                        | Storage request not available yet                | Your PVC is Pending â†’ Pod also Pending                           |
| **ImagePullSecret missing for private registry**                   | Kubernetes canâ€™t access private image            | Works only after you configure a secret                          |
| **Network policy / permissions issue**                             | Scheduler can't assign pod due to constraints    | Rare but possible                                                |

ğŸ§ª How to Troubleshoot Step-by-Step
1ï¸âƒ£ Check Pod Status and Events
kubectl describe pod <pod-name>
Look at the bottom: Events section â€” it tells the real reason.

2ï¸âƒ£ Check if Resources are Available
kubectl get nodes -o wide
kubectl describe node <node-name>
If you see messages like:
0/3 nodes are available: insufficient memory / cpu
Then your requests are too high.
3ï¸âƒ£ Check PVC Binding Issue
kubectl get pvc
If PVC is also Pending, fix storage before the pod runs.
4ï¸âƒ£ Check Scheduling Rules
If you're using labels or taints:
kubectl get nodes --show-labels
kubectl describe node <node>
â­ Common scheduler mismatch messages:
node(s) didn't match node selector
node(s) had taints that the pod didn't tolerate
ğŸ›  Example Real-Life Issue
YAML:
resources:
  requests:
    cpu: "2"
    memory: "4Gi"
If your node has only 1 CPU free, scheduler won't assign it, so pod stays pending.

ğŸ©¹ Fix: lower the request:
resources:
  requests:
    cpu: "0.5"
    memory: "512Mi"
Adjust the reource requests and limits in the deployment
kubectl edit deployment <deployment-name>


***node not ready(all the nodes in the cluster are not ready)***
It means Kubernetes cannot talk to the node, so pods cannot run on it.
ğŸ“Œ How to Check Node Status
kubectl get nodes
Example output:
NAME       STATUS     ROLES    AGE     VERSION
node01     NotReady   worker   20d     v1.28
node02     NotReady   worker   20d     v1.28

ğŸ›  How to Fix It (Simple Steps)
1ï¸âƒ£ Check kubelet is running
Describe the Node
kubectl describe node <node-name>
Look for messages under Conditions:
Ready: False
Reason: KubeletNotReady
Message: container runtime is down

2ï¸âƒ£ SSH into the node and check Kubelet
systemctl status kubelet
If not running, start it:
sudo systemctl start kubelet
sudo systemctl enable kubelet

3ï¸âƒ£ Check Node Pressure (Memory, Disk)
Node Pressure means the node is running low on memory or disk space, so Kubernetes marks it as NotReady to protect itself.

Types of Pressure:
| Pressure Type      | Meaning                             | Example                              |
| ------------------ | ----------------------------------- | ------------------------------------ |
| **MemoryPressure** | Node is running out of RAM          | Too many pods using memory           |
| **DiskPressure**   | Node is running out of disk storage | Logs, images, or files fill the disk |

ğŸ§ª How to Check?
Run:
kubectl describe node <node-name>
If you see:
MemoryPressure: True
DiskPressure: True

ğŸ›  How to Fix Node Pressure (Simple Steps)
âœ… If Memory is Low
The node doesn't have enough RAM.
Fix: Remove extra pods or increase the size of the node.

âœ… If Disk is Full
The node doesn't have enough storage.
Fix: Delete old files, logs, and unused container images.

ğŸ§¹ Simple Cleanup Commands
If using Docker:
docker system prune -a
If using containerd:
crictl rmi --prune



*** service not reachable, how to troubleshoot ***
ğŸš¨ When a Service is Not Reachable
It means traffic is not passing from:
Client â†’ Service â†’ Pod

ğŸ§ª Step-by-Step Troubleshooting (Simple)
1ï¸âƒ£ Check if Service Exists
kubectl get svc
Make sure service name and namespace are correct.

2ï¸âƒ£ Check Service Type
kubectl describe svc <service-name>
Types:
| Type         | When used                                         |
| ------------ | ------------------------------------------------- |
| ClusterIP    | Inside cluster only                               |
| NodePort     | Accessible from outside using `<NodeIP>:NodePort` |
| LoadBalancer | Cloud access (AWS/Azure/GCP)                      |
If you're trying to access a ClusterIP from outside the cluster, it won't work.

3ï¸âƒ£ Check if Service Has Endpoints
For a Service to send traffic to a Pod, the labels on the Pod must match the selector in the Service. If they donâ€™t match, the Service has no endpoints, and traffic wonâ€™t reach the Pod.
What are "Endpoints"?
Endpoints are the IP addresses of pods that a service will send traffic to.
If a service has no endpoints, it means:
The service does not know which pod it should talk to.

ğŸ’¡ Why does this happen?
Because Kubernetes finds pods based on labels.
A Service has a selector, and it looks for pods with matching labels.

ğŸ§  Example to Understand
âœ… Service YAML:
selector:
  app: web
This means:
"Send traffic only to pods that have the label app=web".

âŒ Pod Labels (incorrect)
labels:
  app: backend

Since app=backend â‰  app=web, the service will find zero pods.
So endpoints will be:
<none>
âœ” Pod Labels (correct)
labels:
  app: web

Now labels match â†’ service will find the pod â†’ endpoints will be created.
ğŸ›  How to Check
1ï¸âƒ£ Check service selector:
kubectl describe svc <service-name>
You will see something like:
Selector: app=web

2ï¸âƒ£ Check pod labels:
kubectl get pods --show-labels
Example output:
pod1   Running   app=backend
pod2   Running   app=web
Only the pod with app=web will become an endpoint.

5ï¸âƒ£ Check Pod is Running and Ready
kubectl get pods
If pod is:
CrashLoopBackOff
Error
Pending
â†’ Service cannot route traffic.

6ï¸âƒ£ Test Inside Cluster
Use busybox or curl pod:
kubectl run test --image=busybox:1.28 -it -- /bin/sh

Then test:
curl http://<service-name>:<port>
If this works but external access fails â†’ issue is NodePort / LoadBalancer.

7ï¸âƒ£ Check Firewall / NodePort Access
If using NodePort:
curl <NodeIP>:<NodePort>
If blocked â†’ firewall or security group issue.

5.What is Service and types of services
*** what is pv and pvc?what happens if pod is deleted to pvc-perisitenceVolumeReclaimPolicy and command to check pv and pvc? ***
| Object  | Meaning             |
| ------- | ------------------- |
| **PV**  | The actual storage  |
| **PVC** | Request for storage |

ğŸ” What happens if a Pod is deleted?
The Pod is deleted, but the PVC and PV remain.
So when a new pod comes back using the same PVC â†’ it can still access the same data.

ğŸ—‘ What happens when PVC is deleted?
This depends on the Reclaim Policy of the PV.

ğŸ“Œ PersistenceVolumeReclaimPolicy Types
| Policy            | Meaning        | What happens when PVC is deleted         |
| ----------------- | -------------- | ---------------------------------------- |
| **Retain**        | Keep data safe | PV keeps data; admin must clean manually |
| **Delete**        | Delete storage | PV and actual storage are deleted        |
| **Recycle (old)** | Wipes data     | Not used in modern Kubernetes            |

ğŸ§  Simple Example:
If policy = Retain
Pod deleted â†’ data still there
âœ” When PVC is deleted
The PVC (request) is gone.
But the PV and data are NOT deleted.
Kubernetes marks the PV as:
Released

This means:
â€œThe data still exists, but Kubernetes wonâ€™t reuse it automatically until an admin cleans or resets it.â€

If policy = Delete
PVC deleted â†’ PV + data removed forever

ğŸ§ª Commands to Check PV and PVC
Check all PVs:
kubectl get pv

Check details of a specific PV:
kubectl describe pv <pv-name>

Check all PVCs:
kubectl get pvc

Check details of a specific PVC:
kubectl describe pvc <pvc-name>
ğŸ‘‰ This is how data remains safe even if the pod restarts or crashes.


*** progressdeadline error-we can increase the replicas pods ***
we can use autoscaling Hpa(to increase pods) and vpa(to cpu and memory for existing pods)

ğŸš¨ What is a ProgressDeadlineExceeded error?
This error happens when a Deployment takes too long to become Ready.
Kubernetes waits for a certain time (default 10 minutes).
If pods are not running and healthy within that time, Kubernetes shows:
ProgressDeadlineExceeded

ğŸ” Why does it happen?
Common reasons:
New pods failing to start
Image pull error
Readiness/Liveness probe failing
Not enough CPU/Memory
Too few replicas for load

ğŸ›  How to Fix It (Simple)
âœ… 1ï¸âƒ£ Increase Replica Count
If the application needs more pods to handle traffic:
kubectl scale deploy <deployment-name> --replicas=5
This adds more pods manually.

âœ… 2ï¸âƒ£ Use HPA (Horizontal Pod Autoscaler)
This automatically increases or decreases pod count based on CPU, memory, or custom metrics.
Example:
kubectl autoscale deployment <deployment-name> --cpu-percent=50 --min=2 --max=10
Meaning:
If CPU goes above 50%, Kubernetes will automatically create more pods (up to 10).
âœ… 3ï¸âƒ£ Use VPA (Vertical Pod Autoscaler)

This adjusts CPU and memory of existing pods, instead of creating more pods.
Useful when pods are crashing due to insufficient resources.
Example install-based command:
VPA will recommend or auto adjust resources.
(Not a single CLI command â€” requires CRDs enabled.)


*** Kubernetes architecture ***
ğŸ§  1ï¸âƒ£ Control Plane (Master components)-decides where your application should run and monitors the health of the application
These components manage and control the cluster.
| Component              | Simple Meaning                                             |
| ---------------------- | ---------------------------------------------------------- |
| **API Server**         | Entry point for all Kubernetes commands (kubectl talks to this)         |
| **etcd**               | Database that stores all cluster data (state).             |
| **Scheduler**          | Decides which node should run a pod.                       |
| **Controller Manager** | Ensures desired state (e.g., keeps replica count correct). |

ğŸ–¥ï¸ 2ï¸âƒ£ Worker Nodes
These nodes run the actual applications (pods).
| Component                                 | Simple Meaning                                |
| ----------------------------------------- | --------------------------------------------- |
| **Kubelet**                               | Agent on each node that manages pods.         |
| **Container Runtime (Docker/containerd)** | Runs containers.                              |
| **Kube-Proxy**                            | Manages networking and service communication. ,and rouete trafice to the right pods|

ğŸ“¦ Pods
Smallest running unit in Kubernetes.
Runs one or more containers.

ğŸ— Deployment
Defines how many pods should run.
Kubernetes ensures they remain running.

ğŸŒ Service
Provides a stable network endpoint to access pods.

kubectl apply -f deployment.yaml
API Server receives request.
Scheduler decides the best worker node.
Kubelet on that node creates the pod.
Container Runtime starts the container.
Kube-Proxy helps networking so pod can communicate.



*** you are using external ip not reachable? ans-network policies????not sure ***
External IP is not reachable because the traffic is blocked somewhere â€” check service type, endpoints, network policy, and firewall rules.
ğŸ›  Quick Troubleshooting Steps

1ï¸âƒ£ Check service type
kubectl get svc
If type is ClusterIP, external access wonâ€™t work.

2ï¸âƒ£ Check endpoints
kubectl get endpoints <service-name>
If empty â†’ fix labels.

3ï¸âƒ£ Check network policies
kubectl get networkpolicy
If policies exist, they may block inbound traffic.

4ï¸âƒ£ Check Node/Cloud Firewall
Open port if using NodePort (range: 30000â€“32767).

***How to increase cpu and memory to pod ?command ***
ğŸ”§ How to Increase CPU and Memory for a Pod?
You cannot change resources directly on a running Pod.
Instead, you update the Deployment, StatefulSet, or ReplicaSet that manages the Pod.
Kubernetes will then restart the Pod with new resources.
ğŸ“ Example YAML Before:
resources:
  requests:
    cpu: "100m"
    memory: "256Mi"
  limits:
    cpu: "200m"
    memory: "512Mi"

ğŸ“ After Increasing:
resources:
  requests:
    cpu: "500m"
    memory: "512Mi"
  limits:
    cpu: "1"
    memory: "1Gi"

ğŸ›  Apply Change:
If this is part of a Deployment file:
kubectl apply -f deployment.yaml
Kubernetes will recreate pods with the updated values.

ğŸš€ Quick Method (No YAML)
You can edit the deployment directly:
kubectl edit deployment <deployment-name>
Then modify:
resources:
  requests:
    cpu: "500m"
    memory: "512Mi"
  limits:
    cpu: "1"
    memory: "1Gi"
Save â†’ Pods restart with new CPU/Memory.

âš™ï¸ Using Autoscaling
ğŸ”¹ HPA (Horizontal Pod Autoscaler) â†’ Increase Number of Pods
kubectl autoscale deployment <deployment-name> --cpu-percent=50 --min=2 --max=5
ğŸ”¹ VPA (Vertical Pod Autoscaler) â†’ Automatically adjust CPU/Memory
(If installed)
kubectl apply -f vpa.yaml

*** we have pod in one namepspace wnat to  communicate with other other namespace?-namespace selector network policies,Rbac ***
â“ Can a Pod in one namespace communicate with a pod in another namespace?
ğŸ‘‰ Yes, by default Kubernetes allows cross-namespace communication.
You can access another pod using:
<service-name>.<namespace>.svc.cluster.local
Example:
curl http://app-service.dev.svc.cluster.local
But sometimes communication may not work because of:
ğŸš« 1ï¸âƒ£ Network Policies
NetworkPolicies can block traffic between namespaces.
To allow communication, you can use a namespaceSelector.
Example Network Policy Allowing Traffic From Another Namespace ğŸ‘‡
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-from-dev
  namespace: prod
spec:
  podSelector: {} 
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          allowed: "true"

Then label the allowed namespace:
kubectl label namespace dev allowed=true
ğŸš« 2ï¸âƒ£ RBAC Permissions
Even if network allows communication, some operations (like list pods, exec, logs) may require RBAC access.
Example RoleBinding to allow a service account from namespace dev to access resources in prod:

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: allow-dev-access
  namespace: prod
subjects:
- kind: ServiceAccount
  name: app-sa
  namespace: dev
roleRef:
  kind: Role
  name: view
  apiGroup: rbac.authorization.k8s.io


*** In your project how you are using RBAC ***
Example:
| Role                      | What They Can Do                                                    |
| ------------------------- | ------------------------------------------------------------------- |
| **Admin**                 | Full control of the cluster                                         |
| **Developer**             | Can view pods, logs, and update deployments only in their namespace |
| **Tester/QA**             | Read-only access (cannot edit or delete anything)                   |
| **CI/CD Service Account** | Can deploy applications but cannot delete cluster resources         |

ğŸ’¬ How I use RBAC in my project
In my project, RBAC (Role-Based Access Control) is used to control who can do what inside the Kubernetes cluster.
We donâ€™t give full admin access to everyone â€” instead, we give permissions based on roles.

ğŸ§  Why we use RBAC?
To avoid accidental deletion of resources
To enforce least privilege principle
To make the cluster secure

ğŸ›  How we configure RBAC
We create:
Role or ClusterRole â†’ defines permissions
RoleBinding or ClusterRoleBinding â†’ assigns the role to a user, group, or service account

ğŸ“Œ Example we use in our environment:
Role: Allow developers to manage deployments only
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: dev-role
  namespace: dev
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "watch", "create", "update"]

RoleBinding: Assign role to developer team
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: dev-binding
  namespace: dev
subjects:
- kind: User
  name: developer1
roleRef:
  kind: Role
  name: dev-role
  apiGroup: rbac.authorization.k8s.io

ğŸ” Service Account Usage
Our CI/CD pipeline runs with a Service Account that has limited permissions.
It can:
Deploy application
Update secrets
Manage ConfigMaps
but cannot delete namespaces or cluster-level resources.


Docker
1.what is docker file?and what are the main instructions or components in docker file?from that docker file how to create image and container
2.how to delete the container that was stopped?
first check docker ps -a-status of container
docker images
docker rmi container <containerid>


